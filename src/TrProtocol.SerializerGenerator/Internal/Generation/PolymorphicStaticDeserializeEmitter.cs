using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using TrProtocol.Exceptions;
using TrProtocol.SerializerGenerator.Internal.Extensions;
using TrProtocol.SerializerGenerator.Internal.Models;
using TrProtocol.SerializerGenerator.Internal.Utilities;

namespace TrProtocol.SerializerGenerator.Internal.Generation;

internal static class PolymorphicStaticDeserializeEmitter
{
    public static void Emit(
        SourceProductionContext context,
        Dictionary<string, PolymorphicImplsData> polymorphicPackets) {
        foreach (var polymophic in polymorphicPackets.Values) {

            var polymorphicBase = polymophic.PolymorphicBaseType;
            var implementations = polymophic.Implementations;
            var enumType = polymophic.DiscriminatorEnum;

            if (polymorphicBase is null) {
                continue;
            }

            polymorphicBase.DefSyntax.GetNamespace(out _, out var fullNamespace, out var unit);
            var usings = unit?.Usings.Select(u => u.Name?.ToString() ?? "").Where(u => u is not "").ToArray() ?? [];

            var source = new SourceCodeWriter(1024 * 4);
            source.WriteLine();
            source.WriteLine("// <auto-generated>");
            source.WriteLine();

            foreach (var us in usings
                .Concat(GeneratorUsings.NecessaryUsings)
                .Concat(implementations.Values.Select(l => {
                    l.DefSyntax.GetNamespace(out _, out var ns, out _);
                    return ns;
                }))
                .Distinct()) {
                source.WriteLine($"using {us};");
            }

            List<(string memberName, string memberType)> externalMembers = GenerationHelpers.GetExternalMembers(polymorphicBase.DefSymbol);
            var (externalMemberParams, externalMemberParamsCall) = GenerationHelpers.GetExternalMemberParams(externalMembers);
            source.WriteLine();
            source.Write($"namespace {fullNamespace} ");
            source.BlockWrite((source) => {
                var typeKind = polymorphicBase.IsInterface ? "interface" : polymorphicBase.IsValueType ? "struct" : "class";
                source.Write($"public unsafe partial {typeKind} {polymorphicBase.TypeName} ");
                source.BlockWrite((source) => {

                    if (polymorphicBase.IsGlobalIDRoot) {
                        source.WriteLine($"public const int GlobalIDCount = {polymorphicBase.AllocatedGlobalIDCount};");
                        source.WriteLine("public static abstract int GlobalID { get; }");
                    }

                    source.Write($"public unsafe static {polymorphicBase.TypeName} Read{polymorphicBase.TypeName}(ref void* ptr{(polymorphicBase.IsNetPacket ? ", void* ptr_end" : "")}{(polymorphicBase.IsNetPacket ? ", bool isServerSide" : "")}{externalMemberParams}) ");
                    source.BlockWrite((source) => {
                        if (polymophic.Is7BitEncoded) {
                            source.WriteLine($"{enumType.Name} identity = ({enumType.Name})CommonCode.Read7BitEncodedInt(ref ptr);");
                        }
                        else {
                            source.WriteLine($"{enumType.Name} identity = ({enumType.Name})Unsafe.Read<{enumType.EnumUnderlyingType}>(ptr);");
                            source.WriteLine($"ptr = Unsafe.Add<{enumType.EnumUnderlyingType}>(ptr, 1);");
                        }
                        source.Write($"switch (identity) ");
                        source.BlockWrite((source) => {
                            foreach (var enumValue in enumType.GetMembers().OfType<IFieldSymbol>()) {
                                var match = implementations.FirstOrDefault(a => a.Key == enumValue.Name);
                                var packet = match.Value;
                                if (packet is not null) {
                                    if (packet.IsPolymorphic) {
                                        source.WriteLine($"case {enumType.Name}.{enumValue.Name}: return {packet.TypeName}.Read{packet.TypeName}(ref ptr{(polymorphicBase.IsNetPacket ? ", ptr_end" : "")}{(polymorphicBase.IsNetPacket ? ", isServerSide" : "")}{externalMemberParamsCall});");
                                    }
                                    else {
                                        source.WriteLine($"case {enumType.Name}.{enumValue.Name}: return new {packet.TypeName}(ref ptr{(packet.IsLengthAware ? ", ptr_end" : "")}{(packet.IsSideSpecific ? ", isServerSide" : "")}{externalMemberParamsCall});");
                                    }
                                }
                            }
                            source.WriteLine($"default: throw new {nameof(UnknownDiscriminatorException)}(typeof({polymorphicBase.TypeName}), identity, (long)identity);");
                        });
                    });
                });
            });
            context.AddSource($"{polymorphicBase.DefSyntax.GetFullName()}.static.seri.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        }
    }
}

